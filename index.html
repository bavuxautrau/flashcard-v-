<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Web H·ªçc T·ª´ V·ª±ng IPA + SM-2</title>
<style>
body { font-family: Arial, sans-serif; background:#f0f8ff; display:flex; flex-direction:column; align-items:center; padding:20px;}
h1 { color:#333; }
.flashcard { width:350px; height:200px; border:2px solid #333; border-radius:10px; display:flex; justify-content:center; align-items:center; text-align:center; background-color:#fff; margin:20px; font-size:24px; cursor:pointer; transition: transform 0.6s; transform-style: preserve-3d; perspective:1000px; position:relative;}
.flashcard.flipped { transform: rotateY(180deg);}
.front, .back { position:absolute; width:320px; height:180px; backface-visibility:hidden; display:flex; flex-direction:column; justify-content:center; align-items:center; border-radius:10px; padding:10px;}
.back { transform: rotateY(180deg); background-color:#ffe4e1;}
input, button, select { margin:5px; padding:5px; font-size:16px;}
table { border-collapse: collapse; margin-top:10px; max-width:90%;}
th, td { border:1px solid #333; padding:5px 10px; text-align:center;}
.phonetic { font-size:16px; margin-top:5px; color:#555;}
#resultPronounce { margin-top:10px; font-weight:bold; color:#006400; }
</style>
</head>
<body>

<h1>Web H·ªçc T·ª´ V·ª±ng IPA + SM-2</h1>

<div class="flashcard" id="flashcard">
  <div class="front" id="front">Click ƒë·ªÉ l·∫≠t</div>
  <div class="back" id="back"></div>
</div>

<div>
  <input type="text" id="newWord" placeholder="T·ª´ ti·∫øng Anh">
  <input type="text" id="newMeaning" placeholder="Nghƒ©a ti·∫øng Vi·ªát">
  <input type="text" id="newCategory" placeholder="Danh m·ª•c (t·ª± nh·∫≠p)">
  <button onclick="addWord()">Th√™m t·ª´ m·ªõi</button>
  <button onclick="nextWord()">T·ª´ ti·∫øp theo</button>
  <button onclick="markKnown()">ƒê√£ thu·ªôc</button>
  <button onclick="reviewKnown()">√în l·∫°i t·ª´ ƒë√£ thu·ªôc</button>
  <button onclick="playPronunciation()">Ph√°t √¢m</button>
  <button id="speakBtn">üé§ N√≥i t·ª´ n√†y</button>
</div>

<p id="resultPronounce"></p>

<h3>Danh s√°ch t·ª´ (S·ª≠a/X√≥a)</h3>
<select id="filterCategory" onchange="renderTable()">
  <option value="">T·∫•t c·∫£ danh m·ª•c</option>
</select>
<table id="wordTable">
  <thead>
    <tr><th>T·ª´</th><th>Nghƒ©a</th><th>Danh m·ª•c</th><th>ƒê√£ thu·ªôc</th><th>H√†nh ƒë·ªông</th></tr>
  </thead>
  <tbody></tbody>
</table>

<script>
// ==========================
// D·ªØ li·ªáu t·ª´ v·ª±ng
// ==========================
let words = JSON.parse(localStorage.getItem('words')) || [
  {eng:"apple", vi:"qu·∫£ t√°o", category:"ƒê·ªì ƒÉn", known:false, lastReview:Date.now(), interval:1, phonetic:"Àà√¶p(…ô)l"},
  {eng:"cat", vi:"con m√®o", category:"ƒê·ªông v·∫≠t", known:false, lastReview:Date.now(), interval:1, phonetic:"k√¶t"}
];
let currentIndex = 0;
let inReviewMode = false;

// ==========================
// DOM elements
// ==========================
const flashcard = document.getElementById("flashcard");
const front = document.getElementById("front");
const back = document.getElementById("back");
const wordTable = document.querySelector("#wordTable tbody");
const filterCategory = document.getElementById("filterCategory");
const speakBtn = document.getElementById("speakBtn");
const resultPronounce = document.getElementById("resultPronounce");

// ==========================
// Flashcard
// ==========================
async function showWord() {
  let activeWords = inReviewMode ? words.filter(w=>w.known) : words.filter(w=>!w.known);
  if(filterCategory.value) activeWords = activeWords.filter(w=>w.category===filterCategory.value);
  if(activeWords.length===0){
    front.textContent = inReviewMode?"Ch∆∞a c√≥ t·ª´ ƒë·ªÉ √¥n!":"B·∫°n ƒë√£ h·ªçc h·∫øt t·ª´ m·ªõi!";
    back.innerHTML = "";
    return;
  }
  currentIndex = currentIndex % activeWords.length;
  let word = activeWords[currentIndex];

  front.textContent = word.eng;

  // L·∫•y IPA th·ª±c n·∫øu ch∆∞a c√≥
  if(!word.phonetic) word.phonetic = await fetchIPA(word.eng);

  back.innerHTML = `${word.vi} <div class="phonetic">[${word.phonetic}]</div>`;
  localStorage.setItem('words', JSON.stringify(words));
  flashcard.classList.remove("flipped");

  // Nh·∫Øc nh·ªü √¥n t·∫≠p
  let nextReviewTime = word.lastReview + word.interval*24*60*60*1000;
  if(nextReviewTime <= Date.now() && !inReviewMode){
    alert("B·∫°n n√™n √¥n t·ª´: " + word.eng);
  }
}

flashcard.addEventListener("click", ()=>{ flashcard.classList.toggle("flipped"); });
function nextWord(){ currentIndex++; showWord(); }

// ==========================
// Ph√°t √¢m
// ==========================
function playPronunciation(){
  let activeWords = inReviewMode ? words.filter(w=>w.known) : words.filter(w=>!w.known);
  if(filterCategory.value) activeWords = activeWords.filter(w=>w.category===filterCategory.value);
  if(activeWords.length===0) return;
  const utterance = new SpeechSynthesisUtterance(activeWords[currentIndex].eng);
  utterance.lang = 'en-US';
  utterance.rate = 0.9;
  speechSynthesis.speak(utterance);
}

// ==========================
// Luy·ªán ph√°t √¢m b·∫±ng micro
// ==========================
let recognition;
if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  recognition = new SpeechRecognition();
  recognition.lang = "en-US"; // gi·ªçng M·ªπ
  recognition.interimResults = false;
  recognition.maxAlternatives = 1;

  recognition.onresult = (event) => {
    let spokenText = event.results[0][0].transcript.trim().toLowerCase();
    let activeWords = inReviewMode ? words.filter(w=>w.known) : words.filter(w=>!w.known);
    if(filterCategory.value) activeWords = activeWords.filter(w=>w.category===filterCategory.value);
    if(activeWords.length===0) return;
    let correctWord = activeWords[currentIndex].eng.toLowerCase();
    if (spokenText === correctWord) {
      resultPronounce.textContent = `‚úÖ Chu·∫©n r·ªìi: ${spokenText}`;
      setTimeout(()=>{ nextWord(); }, 1000);
    } else {
      resultPronounce.textContent = `‚ùå B·∫°n n√≥i: "${spokenText}", c·∫ßn: "${correctWord}"`;
    }
  };

  recognition.onerror = (event) => {
    resultPronounce.textContent = "‚ö† L·ªói nh·∫≠n di·ªán gi·ªçng n√≥i: " + event.error;
  };
} else {
  resultPronounce.textContent = "Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ nh·∫≠n di·ªán gi·ªçng n√≥i!";
}

speakBtn.addEventListener("click", ()=>{
  if(recognition) {
    resultPronounce.textContent = "üé§ ƒêang nghe...";
    recognition.start();
  }
});

// ==========================
// L·∫•y IPA t·ª´ DictionaryAPI
// ==========================
async function fetchIPA(word){
  try {
    let res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
    let data = await res.json();
    if(data[0] && data[0].phonetics && data[0].phonetics.length>0){
      for(let p of data[0].phonetics){
        if(p.text) return p.text; // v√≠ d·ª• Àà√¶p(…ô)l
      }
    }
    return generateFakeIPA(word);
  } catch(e){ console.log(e); return generateFakeIPA(word); }
}

// T·∫°m th·ªùi t·∫°o IPA gi·∫£
function generateFakeIPA(word){
  return word.toLowerCase().split("").join(".");
}

// ==========================
// Th√™m/S·ª≠a/X√≥a t·ª´
// ==========================
function addWord(){
  const eng = document.getElementById("newWord").value.trim();
  const vi = document.getElementById("newMeaning").value.trim() || eng;
  const category = document.getElementById("newCategory").value.trim() || "Kh√°c";
  if(!eng) return alert("Vui l√≤ng nh·∫≠p t·ª´ ti·∫øng Anh!");
  let now = Date.now();
  words.push({eng, vi, category, known:false, lastReview:now, interval:1, phonetic:""});
  localStorage.setItem('words', JSON.stringify(words));
  document.getElementById("newWord").value=""; document.getElementById("newMeaning").value=""; document.getElementById("newCategory").value="";
  updateCategoryOptions(); inReviewMode=false; showWord(); renderTable();
}

function editWord(index){
  let word = words[index];
  let newEng = prompt("S·ª≠a t·ª´ ti·∫øng Anh:", word.eng);
  if(!newEng) return;
  let newVi = prompt("S·ª≠a nghƒ©a ti·∫øng Vi·ªát:", word.vi) || newEng;
  let newCategory = prompt("S·ª≠a danh m·ª•c:", word.category) || "Kh√°c";
  word.eng=newEng; word.vi=newVi; word.category=newCategory; word.phonetic="";
  localStorage.setItem('words', JSON.stringify(words));
  updateCategoryOptions(); renderTable(); showWord();
}

function deleteWord(index){
  if(!confirm("B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a t·ª´ n√†y?")) return;
  words.splice(index,1);
  localStorage.setItem('words', JSON.stringify(words));
  updateCategoryOptions(); renderTable(); showWord();
}

// ==========================
// SM-2 & ƒê√°nh d·∫•u ƒë√£ thu·ªôc
// ==========================
function markKnown(){
  let activeWords = words.filter(w=>!w.known);
  if(filterCategory.value) activeWords = activeWords.filter(w=>w.category===filterCategory.value);
  if(activeWords.length===0) return;
  let word = activeWords[currentIndex];
  word.known=true;
  word.lastReview=Date.now();
  word.interval = nextInterval(word.interval);
  localStorage.setItem('words', JSON.stringify(words));
  inReviewMode=false; showWord(); renderTable();
}

function nextInterval(prev){
  if(prev<3) return 3;
  if(prev<7) return 7;
  if(prev<14) return 14;
  if(prev<30) return 30;
  return 30;
}

// ==========================
// √în l·∫°i t·ª´ ƒë√£ thu·ªôc
// ==========================
function reviewKnown(){
  let knownWords = words.filter(w=>w.known);
  if(filterCategory.value) knownWords = knownWords.filter(w=>w.category===filterCategory.value);
  if(knownWords.length===0) return alert("Ch∆∞a c√≥ t·ª´ n√†o ƒë·ªÉ √¥n!");
  inReviewMode=true; currentIndex=0; showWord();
}

// ==========================
// Danh s√°ch t·ª´
// ==========================
function renderTable(){
  wordTable.innerHTML="";
  const selectedCat = filterCategory.value;
  words.forEach((w,i)=>{
    if(selectedCat && w.category!==selectedCat) return;
    let tr = document.createElement("tr");
    tr.innerHTML = `<td>${w.eng}</td><td>${w.vi}</td><td>${w.category}</td><td>${w.known?"‚úî":"‚ùå"}</td>
    <td><button onclick="editWord(${i})">S·ª≠a</button> <button onclick="deleteWord(${i})">X√≥a</button></td>`;
    wordTable.appendChild(tr);
  });
}

// ==========================
// C·∫≠p nh·∫≠t danh m·ª•c
// ==========================
function updateCategoryOptions(){
  let categories = [...new Set(words.map(w=>w.category))];
  filterCategory.innerHTML='<option value="">T·∫•t c·∫£ danh m·ª•c</option>';
  categories.forEach(cat=>{
    let option = document.createElement("option");
    option.value=cat; option.textContent=cat;
    filterCategory.appendChild(option);
  });
}

// ==========================
// Kh·ªüi t·∫°o
// ==========================
updateCategoryOptions();
showWord();
renderTable();
</script>
</body>
</html>
